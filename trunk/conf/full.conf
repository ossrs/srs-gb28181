# all config for srs

#############################################################################################
# RTMP sections
#############################################################################################
# the rtmp listen ports, split by space, each listen entry is <[ip:]port>
# for example, 192.168.1.100:1935 10.10.10.100:1935
# where the ip is optional, default to 0.0.0.0, that is 1935 equals to 0.0.0.0:1935
listen              1935;
# the pid file
# to ensure only one process can use a pid file
# and provides the current running process id, for script,
# for example, init.d script to manage the server.
# default: ./objs/srs.pid
pid                 ./objs/srs.pid;
# the default chunk size is 128, max is 65536,
# some client does not support chunk size change,
# however, most clients support it and it can improve
# performance about 10%.
# default: 60000
chunk_size          60000;
# the log dir for FFMPEG.
# if enabled ffmpeg, each transcoding stream will create a log file.
# /dev/null to disable the log.
# default: ./objs
ff_log_dir          ./objs;
# the log level for FFMPEG.
#       info warning error fatal panic quiet
#       trace debug verbose
# default: info
ff_log_level        info;
# the log tank, console or file.
# if console, print log to console.
# if file, write log to file. requires srs_log_file if log to file.
# default: file.
srs_log_tank        console;
# the log level, for all log tanks.
# can be: verbose, info, trace, warn, error
# default: trace
srs_log_level       trace;
# when srs_log_tank is file, specifies the log file.
# default: ./objs/srs.log
srs_log_file        ./objs/srs.log;
# the max connections.
# if exceed the max connections, server will drop the new connection.
# default: 1000
max_connections     1000;
# whether start as daemon
# @remark: do not support reload.
# default: on
daemon              off;
# whether use utc_time to generate the time struct,
# if off, use localtime() to generate it,
# if on, use gmtime() instead, which use UTC time.
# default: off
utc_time            off;
# config for the pithy print in ms,
# which always print constant message specified by interval,
# whatever the clients in concurrency.
# default: 10000
pithy_print_ms      10000;

# the work dir for server, to chdir(work_dir) when not empty or "./"
# user can config this directory to change the dir.
# @reamrk do not support reload.
# default: ./
work_dir ./;
# whether quit when parent process changed,
# used for supervisor mode(not daemon), srs should always quit when 
# supervisor process exited.
# @remark conflict with daemon, error when both daemon and asprocess are on.
# @reamrk do not support reload.
# default: off
asprocess off;
# Whether client empty IP is ok, for example, health checking by SLB.
# If ok(on), we will ignore this connection without warnings or errors.
# default: on
empty_ip_ok on;

# For gracefully quit, wait for a while then close listeners,
# because K8S notify SRS with SIGQUIT and update Service simultaneously,
# maybe there is some new connections incoming before Service updated.
# @see https://github.com/ossrs/srs/issues/1595#issuecomment-587516567
# default: 2300
grace_start_wait 2300;
# For gracefully quit, final wait for cleanup in milliseconds.
# @see https://github.com/ossrs/srs/issues/1579#issuecomment-587414898
# default: 3200
grace_final_wait 3200;
# Whether force gracefully quit, never fast quit.
# By default, SIGTERM which means fast quit, is sent by K8S, so we need to
# force SRS to treat SIGTERM as gracefully quit for gray release or canary.
# @see https://github.com/ossrs/srs/issues/1579#issuecomment-587475077
# default: off
force_grace_quit off;
# Whether disable daemon for docker.
# If on, it will set daemon to off in docker, even daemon is on.
# default: on
disable_daemon_for_docker on;
# Whether auto reload by watching the config file by inotify.
# default: off
inotify_auto_reload off;
# Whether enable inotify_auto_reload for docker.
# If on, it will set inotify_auto_reload to on in docker, even it's off.
# default: on
auto_reload_for_docker on;

# For tcmalloc, the release rate.
# @see https://gperftools.github.io/gperftools/tcmalloc.html
# @remark Should run configure --with-gperf
# default: 0.8
tcmalloc_release_rate 0.8;

# Query the latest available version of SRS, write a log to notice user to upgrade.
# @see https://github.com/ossrs/srs/issues/2424
# @see https://github.com/ossrs/srs/issues/2508
# Default: on
query_latest_version on;

# For system circuit breaker.
circuit_breaker {
    # Whether enable the circuit breaker.
    # Default: on
    enabled on;
    # The CPU percent(0, 100) ever 1s, as system high water-level, which enable the circuit-break
    # mechanism, for example, NACK will be disabled if high water-level.
    # Default: 90
    high_threshold 90;
    # Reset the high water-level, if number of pulse under high_threshold.
    # @remark 0 to disable the high water-level.
    # Default: 2
    high_pulse 2;
    # The CPU percent(0, 100) ever 1s, as system critical water-level, which enable the circuit-break
    # mechanism, for example, TWCC will be disabled if high water-level.
    # @note All circuit-break mechanism of high-water-level scope are enabled in critical.
    # Default: 95
    critical_threshold 95;
    # Reset the critical water-level, if number of pulse under critical_threshold.
    # @remark 0 to disable the critical water-level.
    # Default: 1
    critical_pulse 1;
    # If dying, also drop packets for players.
    # Default: 99
    dying_threshold 99;
    # If CPU exceed the dying_pulse times, enter dying.
    # @remark 0 to disable the dying water-level.
    # Default: 5
    dying_pulse 5;
}

#############################################################################################
# heartbeat/stats sections
#############################################################################################
# heartbeat to api server
# @remark, the ip report to server, is retrieve from system stat,
#       which need the config item stats.network.
heartbeat {
    # whether heartbeat is enabled.
    # default: off
    enabled         off;
    # the interval seconds for heartbeat,
    # recommend 0.3,0.6,0.9,1.2,1.5,1.8,2.1,2.4,2.7,3,...,6,9,12,....
    # default: 9.9
    interval        9.3;
    # when startup, srs will heartbeat to this api.
    # @remark: must be a restful http api url, where SRS will POST with following data:
    #   {
    #       "device_id": "my-srs-device",
    #       "ip": "192.168.1.100"
    #   }
    # default: http://127.0.0.1:8085/api/v1/servers
    url             http://127.0.0.1:8085/api/v1/servers;
    # the id of device.
    device_id       "my-srs-device";
    # whether report with summaries
    # if on, put /api/v1/summaries to the request data:
    #   {
    #       "summaries": summaries object.
    #   }
    # @remark: optional config.
    # default: off
    summaries       off;
}

# system statistics section.
# the main cycle will retrieve the system stat,
# for example, the cpu/mem/network/disk-io data,
# the http api, for instance, /api/v1/summaries will show these data.
# @remark the heartbeat depends on the network,
#       for example, the eth0 maybe the device which index is 0.
stats {
    # Whether enable the stat of system resources.
    # Default: on
    enabled         on;
    # the index of device ip.
    # we may retrieve more than one network device.
    # default: 0
    network         0;
    # the device name to stat the disk iops.
    # ignore the device of /proc/diskstats if not configured.
    disk            sda sdb xvda xvdb;
}

#############################################################################################
# HTTP sections
#############################################################################################
# api of srs.
# the http api config, export for external program to manage srs.
# user can access http api of srs in browser directly, for instance, to access by:
#       curl http://192.168.1.170:1985/api/v1/reload
# which will reload srs, like cmd killall -1 srs, but the js can also invoke the http api,
# where the cli can only be used in shell/terminate.
http_api {
    # whether http api is enabled.
    # default: off
    enabled         on;
    # the http api listen entry is <[ip:]port>
    # for example, 192.168.1.100:1985
    # where the ip is optional, default to 0.0.0.0, that is 1985 equals to 0.0.0.0:1985
    # default: 1985
    listen          1985;
    # whether enable crossdomain request.
    # default: on
    crossdomain     on;
    # the HTTP RAW API is more powerful api to change srs state and reload.
    raw_api {
        # whether enable the HTTP RAW API.
        # default: off
        enabled             off;
        # whether enable rpc reload.
        # default: off
        allow_reload        off;
        # whether enable rpc query.
        # Always off by https://github.com/ossrs/srs/issues/2653
        #allow_query         off;
        # whether enable rpc update.
        # Always off by https://github.com/ossrs/srs/issues/2653
        #allow_update        off;
    }
    # For https_api or HTTPS API.
    https {
        # Whether enable HTTPS API.
        # default: off
        enabled on;
        # The listen endpoint for HTTPS API.
        # default: 1990
        listen 1990;
        # The SSL private key file, generated by:
        #       openssl genrsa -out server.key 2048
        # default: ./conf/server.key
        key ./conf/server.key;
        # The SSL public cert file, generated by:
        #       openssl req -new -x509 -key server.key -out server.crt -days 3650 -subj "/C=CN/ST=Beijing/L=Beijing/O=Me/OU=Me/CN=ossrs.net"
        # default: ./conf/server.crt
        cert ./conf/server.crt;
    }
}
# embedded http server in srs.
# the http streaming config, for HLS/HDS/DASH/HTTPProgressive
# global config for http streaming, user must config the http section for each vhost.
# the embed http server used to substitute nginx in ./objs/nginx,
# for example, srs running in arm, can provides RTMP and HTTP service, only with srs installed.
# user can access the http server pages, generally:
#       curl http://192.168.1.170:80/srs.html
# which will show srs version and welcome to srs.
# @remark, the http embedded stream need to config the vhost, for instance, the __defaultVhost__
# need to open the feature http of vhost.
http_server {
    # whether http streaming service is enabled.
    # default: off
    enabled         on;
    # the http streaming listen entry is <[ip:]port>
    # for example, 192.168.1.100:8080
    # where the ip is optional, default to 0.0.0.0, that is 8080 equals to 0.0.0.0:8080
    # @remark, if use lower port, for instance 80, user must start srs by root.
    # default: 8080
    listen          8080;
    # the default dir for http root.
    # default: ./objs/nginx/html
    dir             ./objs/nginx/html;
    # whether enable crossdomain request.
    # for both http static and stream server and apply on all vhosts.
    # default: on
    crossdomain     on;
    # For https_server or HTTPS Streaming.
    https {
        # Whether enable HTTPS Streaming.
        # default: off
        enabled on;
        # The listen endpoint for HTTPS Streaming.
        # default: 8088
        listen 8088;
        # The SSL private key file, generated by:
        #       openssl genrsa -out server.key 2048
        # default: ./conf/server.key
        key ./conf/server.key;
        # The SSL public cert file, generated by:
        #       openssl req -new -x509 -key server.key -out server.crt -days 3650 -subj "/C=CN/ST=Beijing/L=Beijing/O=Me/OU=Me/CN=ossrs.net"
        # default: ./conf/server.crt
        cert ./conf/server.crt;
    }
}

#############################################################################################
# Streamer sections
#############################################################################################
# the streamer cast stream from other protocol to SRS over RTMP.
# @see https://github.com/ossrs/srs/tree/develop#stream-architecture

# MPEGTS over UDP
stream_caster {
    # whether stream caster is enabled.
    # default: off
    enabled         on;
    # the caster type of stream, the casters:
    #       mpegts_over_udp, MPEG-TS over UDP caster.
    caster          mpegts_over_udp;
    # the output rtmp url.
    # for mpegts_over_udp caster, the typically output url:
    #           rtmp://127.0.0.1/live/livestream
    output          rtmp://127.0.0.1/live/livestream;
    # the listen port for stream caster.
    #       for mpegts_over_udp caster, listen at udp port. for example, 8935.
    listen          8935;
}

# FLV
stream_caster {
    # whether stream caster is enabled.
    # default: off
    enabled         on;
    # the caster type of stream, the casters:
    #       flv, FLV over HTTP by POST.
    caster          flv;
    # the output rtmp url.
    # for flv caster, the typically output url:
    #           rtmp://127.0.0.1/[app]/[stream]
    #       for example, POST to url:
    #           http://127.0.0.1:8936/live/livestream.flv
    #       where the [app] is "live" and [stream] is "livestream", output is:
    #           rtmp://127.0.0.1/live/livestream
    output          rtmp://127.0.0.1/[app]/[stream];
    # the listen port for stream caster.
    #       for flv caster, listen at tcp port. for example, 8936.
    listen          8936;
}

# GB28181
stream_caster {
    # whether stream caster is enabled.
    # default: off
    enabled         on;
    # the caster type of stream, the casters:
    #       gb28181, Push GB28181 to SRS.
    caster          gb28181;
    # the output rtmp url.
    # for gb28181 caster, the typically output url:
    #           rtmp://127.0.0.1/live/[stream]
    #       where the [stream] is the VideoChannelCodecID.
    output          rtmp://127.0.0.1/live/[stream];
    # the listen port for stream caster.
    #       for gb28181 caster, listen at udp port. for example, 9000.
    # @remark We can bundle all gb28181 to this port, to reuse this port.
    #       User can choose to bundle port in API port_mode or SIP invite_port_fixed.
    listen          9000;
    # Listen as TCP if on; otherwise, listen as UDP.
    # default: off
    tcp_enable      off;
    # If not bundle ports, use specified ports for each stream.
    rtp_port_min        58200;
    rtp_port_max        58300;
    # Whether wait for keyframe then forward to RTMP.
    # default: on
    wait_keyframe       on;
    # Max timeout in seconds for RTP stream, if timeout, RTCP bye and close stream.
    # default: 30
    rtp_idle_timeout    30;
    # Whether has audio.
    # @remark Flash/RTMP only supports 11025 22050 44100 sample rate, if not the audio may corrupt.
    # default: off
    audio_enable        off;
    # The exposed IP to receive media stream.
    #       *           Retrieve server IP automatically, from all network interfaces.
    #       eth0        Retrieve server IP by specified network interface name. # TODO: Implements it.
    #       $CANDIDATE  Read the IP from ENV variable $EIP, use * if not set, see https://github.com/ossrs/srs/issues/307#issuecomment-599028124
    #       x.x.x.x     A specified IP address or DNS name, which can be access by client such as Chrome.
    # You can specific more than one interface name:
    #       eth0 eth1   Use network interface eth0 and eth1. # TODO: Implements it.
    # Also by IP or DNS names:
    #       192.168.1.3 10.1.2.3 rtc.me # TODO: Implements it.
    # And by multiple ENV variables:
    #       $CANDIDATE $EIP # TODO: Implements it.
    # default: *
    host                *;
    #The media channel is automatically created according to the received RTP packet,
    # and the channel ID is generated according to the RTP SSRC
    # channelid format: 'chid[ssrc]' [ssrc] is rtp's ssrc
    auto_create_channel   off;

    sip {
        # Whether enable embeded SIP server.
        # default: on
        enabled         on;
        # The SIP listen port.
        # default: 5060
        listen          5060;
        # The SIP server ID.
        # default: 34020000002000000001
        serial          34020000002000000001;
        # The SIP server domain.
        # default: 3402000000
        realm           3402000000;
        # The SIP ACK response timeout in seconds.
        # default: 30
        ack_timeout         30;
        # The keepalive timeout in seconds.
        # default: 120
        keepalive_timeout   120;
        # Whether play immediately after registered.
        # default: on
        auto_play           on;
        # Whether bundle media stream port.
        # default: on
        invite_port_fixed   on;
        # interval to query equipment list from equipment or subordinate domain, unit(s)
        # default: 60
        query_catalog_interval 60;
    }
}

#############################################################################################
# SRT server section
#############################################################################################
# @doc https://github.com/ossrs/srs/issues/1147#issuecomment-577607026
srt_server {
    # whether SRT server is enabled.
    # default: off
    enabled on;
    # The UDP listen port for SRT.
    listen 10080;
    # For detail parameters, please read wiki:
    #   https://github.com/ossrs/srs/wiki/v4_CN_SRTParams
    #   https://github.com/ossrs/srs/wiki/v4_EN_SRTParams
    maxbw 1000000000;
    connect_timeout 4000;
    peerlatency 300;
    recvlatency 300;
    # Default app for vmix, see https://github.com/ossrs/srs/pull/1615
    # default: live
    default_app live;
}

#############################################################################################
# WebRTC server section
#############################################################################################
rtc_server {
    # Whether enable WebRTC server.
    # default: off
    enabled on;
    # The udp listen port, we will reuse it for connections.
    # default: 8000
    listen 8000;
    # The exposed candidate IPs, response in SDP candidate line. It can be:
    #       *           Retrieve server IP automatically, from all network interfaces.
    #       eth0        Retrieve server IP by specified network interface name. # TODO: Implements it.
    #       $CANDIDATE  Read the IP from ENV variable, use * if not set.
    #       x.x.x.x     A specified IP address or DNS name, which can be access by client such as Chrome.
    # You can specific more than one interface name:
    #       eth0 eth1   Use network interface eth0 and eth1. # TODO: Implements it.
    # Also by IP or DNS names:
    #       192.168.1.3 10.1.2.3 rtc.me # TODO: Implements it.
    # And by multiple ENV variables:
    #       $CANDIDATE $EIP # TODO: Implements it.
    # @remark For Firefox, the candidate MUST be IP, MUST NOT be DNS name.
    # @see https://github.com/ossrs/srs/wiki/v4_CN_WebRTC#config-candidate
    # default: *
    candidate *;
    # The IP family filter for auto discover candidate, it can be:
    #       ipv4        Filter IP v4 candidates.
    #       ipv6        Filter IP v6 candidates.
    #       all         Filter all IP v4 or v6 candidates.
    # For example, if set to ipv4, we only use the IPv4 address as candidate.
    # default: ipv4
    ip_family ipv4;
    # Whether use ECDSA certificate.
    # If not, use RSA certificate.
    # default: on
    ecdsa on;
    # Whether encrypt RTP packet by SRTP.
    # @remark Should always turn it on, or Chrome will fail.
    # default: on
    encrypt on;
    # We listen multiple times at the same port, by REUSEPORT, to increase the UDP queue.
    # Note that you can set to 1 and increase the system UDP buffer size by net.core.rmem_max
    # and net.core.rmem_default or just increase this to get larger UDP recv and send buffer.
    # default: 1
    reuseport 1;
    # Whether merge multiple NALUs into one.
    # @see https://github.com/ossrs/srs/issues/307#issuecomment-612806318
    # default: off
    merge_nalus off;
    # The black-hole to copy packet to, for debugging.
    # For example, when debugging Chrome publish stream, the received packets are encrypted cipher,
    # we can set the publisher black-hole, SRS will copy the plaintext packets to black-hole, and
    # we are able to capture the plaintext packets by wireshark.
    black_hole {
        # Whether enable the black-hole.
        # default: off
        enabled off;
        # The black-hole address for session.
        addr 127.0.0.1:10000;
    }
}

vhost rtc.vhost.srs.com {
    rtc {
        # Whether enable WebRTC server.
        # default: off
        enabled on;
        # Whether support NACK.
        # default: on
        nack on;
        # Whether directly use the packet, avoid copy.
        # default: on
        nack_no_copy on;
        # Whether support TWCC.
        # default: on
        twcc on;
        # The timeout in seconds for session timeout.
        # Client will send ping(STUN binding request) to server, we use it as heartbeat.
        # default: 30
        stun_timeout 30;
        # The strict check when process stun.
        # default: off
        stun_strict_check on;
        # The role of dtls when peer is actpass: passive or active
        # default: passive
        dtls_role passive;
        # The version of dtls, support dtls1.0, dtls1.2, and auto
        # default: auto
        dtls_version auto;
        # Drop the packet with the pt(payload type), 0 never drop.
        # default: 0
        drop_for_pt 0;
        ###############################################################
        # Whether enable transmuxing RTMP to RTC.
        # If enabled, transcode aac to opus.
        # default: off
        rtmp_to_rtc off;
        # Whether keep B-frame, which is normal feature in live streaming,
        # but usually disabled in RTC.
        # default: off
        keep_bframe off;
        ###############################################################
        # Whether enable transmuxing RTC to RTMP.
        # Default: off
        rtc_to_rtmp off;
        # The PLI interval in seconds, for RTC to RTMP.
        # Note the available range is [0.5, 30]
        # Default: 6.0
        pli_for_rtmp 6.0;
    }
    ###############################################################
    # For transmuxing RTMP to RTC, it will impact the default values if RTC is on.
    # Whether enable min delay mode for vhost.
    # default: on, for RTC.
    min_latency on;
    play {
        # set the MW(merged-write) latency in ms.
        # @remark For WebRTC, we enable pass-timestamp mode, so we ignore this config.
        # default: 0 (For WebRTC)
        mw_latency 0;
        # Set the MW(merged-write) min messages.
        # default: 0 (For Real-Time, that is min_latency on)
        # default: 1 (For WebRTC, that is min_latency off)
        mw_msgs 0;
    }
}

#############################################################################################
# RTMP/HTTP VHOST sections
#############################################################################################
# vhost list, the __defaultVhost__ is the default vhost
# for example, user use ip to access the stream: rtmp://192.168.1.2/live/livestream.
# for which cannot identify the required vhost.
vhost __defaultVhost__ {
}

# the vhost scope configs.
vhost scope.vhost.srs.com {
    # whether the vhost is enabled.
    # if off, all request access denied.
    # default: on
    enabled         off;

    # whether enable min delay mode for vhost.
    # for min latency mode:
    # 1. disable the publish.mr for vhost.
    # 2. use timeout for cond wait for consumer queue.
    # @see https://github.com/ossrs/srs/issues/257
    # default: off (for RTMP/HTTP-FLV)
    # default: on (for WebRTC)
    min_latency     off;

    # whether enable the TCP_NODELAY
    # if on, set the nodelay of fd by setsockopt
    # default: off
    tcp_nodelay     off;

    # the default chunk size is 128, max is 65536,
    # some client does not support chunk size change,
    # vhost chunk size will override the global value.
    # default: global chunk size.
    chunk_size      128;
    
    # The input ack size, 0 to not set.
    # Generally, it's set by the message from peer,
    # but for some peer(encoder), it never send message but use a different ack size.
    # We can chnage the default ack size in server-side, to send acknowledge message,
    # or the encoder maybe blocked after publishing for some time.
    # Default: 0
    in_ack_size     0;
    
    # The output ack size, 0 to not set.
    # This is used to notify the peer(player) to send acknowledge to server.
    # Default: 2500000
    out_ack_size    2500000;
}

# set the chunk size of vhost.
vhost chunksize.srs.com {
    # @see scope.vhost.srs.com
    chunk_size      128;
}

# the vhost disabled.
vhost removed.srs.com {
    # @see scope.vhost.srs.com
    enabled         off;
}

# vhost for stream cluster for RTMP/FLV
vhost cluster.srs.com {
    # The config for cluster.
    cluster {
        # The cluster mode, local or remote.
        #       local: It's an origin server, serve streams itself.
        #       remote: It's an edge server, fetch or push stream to origin server.
        # default: local
        mode            remote;

        # For edge(mode remote), user must specifies the origin server
        # format as: <server_name|ip>[:port]
        # @remark user can specifies multiple origin for error backup, by space,
        # for example, 192.168.1.100:1935 192.168.1.101:1935 192.168.1.102:1935
        origin          127.0.0.1:1935 localhost:1935;

        # For edge(mode remote), whether open the token traverse mode,
        # if token traverse on, all connections of edge will forward to origin to check(auth),
        # it's very important for the edge to do the token auth.
        # the better way is use http callback to do the token auth by the edge,
        # but if user prefer origin check(auth), the token_traverse if better solution.
        # default: off
        token_traverse  off;

        # For edge(mode remote), the vhost to transform for edge,
        # to fetch from the specified vhost at origin,
        # if not specified, use the current vhost of edge in origin, the variable [vhost].
        # default: [vhost]
        vhost           same.edge.srs.com;

        # For edge(mode remote), when upnode(forward to, edge push to, edge pull from) is srs,
        # it's strongly recommend to open the debug_srs_upnode,
        # when connect to upnode, it will take the debug info,
        # for example, the id, source id, pid.
        # please see: https://github.com/ossrs/srs/wiki/v1_CN_SrsLog
        # default: on
        debug_srs_upnode    on;

        # For origin(mode local) cluster, turn on the cluster.
        # @remark Origin cluster only supports RTMP, use Edge to transmux RTMP to FLV.
        # default: off
        # TODO: FIXME: Support reload.
        origin_cluster      off;

        # For origin (mode local) cluster, the co-worker's HTTP APIs.
        # This origin will connect to co-workers and communicate with them.
        # please read: https://github.com/ossrs/srs/wiki/v3_EN_OriginCluster
        # TODO: FIXME: Support reload.
        coworkers           127.0.0.1:9091 127.0.0.1:9092;

        # The protocol to connect to origin.
        #       rtmp, Connect origin by RTMP
        #       flv, Connect origin by HTTP-FLV
        #       flvs, Connect origin by HTTPS-FLV
        # Default: rtmp
        protocol rtmp;

        # Whether follow client protocol to connect to origin.
        # @remark The FLV might use different signature(in query string) to RTMP.
        # Default: off
        follow_client off;
    }
}

# vhost for edge, edge and origin is the same vhost
vhost same.edge.srs.com {
    # @see cluster.srs.com
    cluster {
        mode            remote;
        origin          127.0.0.1:1935 localhost:1935;
        token_traverse  off;
    }
}

# vhost for edge, edge transform vhost to fetch from another vhost.
vhost transform.edge.srs.com {
    # @see cluster.srs.com
    cluster {
        mode            remote;
        origin          127.0.0.1:1935;
        vhost           same.edge.srs.com;
    }
}

# the vhost for srs debug info, whether send args in connect(tcUrl).
vhost debug.srs.com {
    # @see cluster.srs.com
    cluster {
        debug_srs_upnode    on;
    }
}

# the vhost which forward publish streams.
vhost same.vhost.forward.srs.com {
    # forward stream to other servers.
    forward {
        # whether enable the forward.
        # default: off
        enabled on;
        # forward all publish stream to the specified server.
        # this used to split/forward the current stream for cluster active-standby,
        # active-active for cdn to build high available fault tolerance system.
        # format: {ip}:{port} {ip_N}:{port_N}
        destination 127.0.0.1:1936 127.0.0.1:1937;
    }
}

# the play specified configs
vhost play.srs.com {
    # for play client, both RTMP and other stream clients,
    # for instance, the HTTP FLV stream clients.
    play {
        # whether cache the last gop.
        # if on, cache the last gop and dispatch to client,
        #   to enabled fast startup for client, client play immediately.
        # if off, send the latest media data to client,
        #   client need to wait for the next Iframe to decode and show the video.
        # set to off if requires min delay;
        # set to on if requires client fast startup.
        # default: on
        gop_cache       off;
        # the max live queue length in seconds.
        # if the messages in the queue exceed the max length,
        # drop the old whole gop.
        # default: 30
        queue_length    10;

        # about the stream monotonically increasing:
        #   1. video timestamp is monotonically increasing,
        #   2. audio timestamp is monotonically increasing,
        #   3. video and audio timestamp is interleaved/mixed monotonically increasing.
        # it's specified by RTMP specification, @see 3. Byte Order, Alignment, and Time Format
        # however, some encoder cannot provides this feature, please set this to off to ignore time jitter.
        # the time jitter algorithm:
        #   1. full, to ensure stream start at zero, and ensure stream monotonically increasing.
        #   2. zero, only ensure stream start at zero, ignore timestamp jitter.
        #   3. off, disable the time jitter algorithm, like atc.
        # @remark for full, correct timestamp only when |delta| > 250ms.
        # @remark disabled when atc is on.
        # default: full
        time_jitter             full;
        # vhost for atc for hls/hds/rtmp backup.
        # generally, atc default to off, server delivery rtmp stream to client(flash) timestamp from 0.
        # when atc is on, server delivery rtmp stream by absolute time.
        # atc is used, for instance, encoder will copy stream to master and slave server,
        # server use atc to delivery stream to edge/client, where stream time from master/slave server
        # is always the same, client/tools can slice RTMP stream to HLS according to the same time,
        # if the time not the same, the HLS stream cannot slice to support system backup.
        #
        # @see http://www.adobe.com/cn/devnet/adobe-media-server/articles/varnish-sample-for-failover.html
        # @see http://www.baidu.com/#wd=hds%20hls%20atc
        #
        # @remark when atc is on, auto off the time_jitter
        # default: off
        atc             off;
        # whether use the interleaved/mixed algorithm to correct the timestamp.
        # if on, always ensure the timestamp of audio+video is interleaved/mixed monotonically increase.
        # if off, use time_jitter to correct the timestamp if required.
        # @remark to use mix_correct, atc should on(or time_jitter should off).
        # default: off
        mix_correct             off;

        # whether enable the auto atc,
        # if enabled, detect the bravo_atc="true" in onMetaData packet,
        # set atc to on if matched.
        # always ignore the onMetaData if atc_auto is off.
        # default: off
        atc_auto        off;

        # set the MW(merged-write) latency in ms.
        # SRS always set mw on, so we just set the latency value.
        # the latency of stream >= mw_latency + mr_latency
        # the value recomment is [300, 1800]
        # @remark For WebRTC, we enable pass-timestamp mode, so we ignore this config.
        # default: 350 (For RTMP/HTTP-FLV)
        # default: 0 (For WebRTC)
        mw_latency      350;

        # Set the MW(merged-write) min messages.
        # default: 0 (For Real-Time, min_latency on)
        # default: 1 (For WebRTC, min_latency off)
        # default: 8 (For RTMP/HTTP-FLV, min_latency off).
        mw_msgs         8;

        # the minimal packets send interval in ms,
        # used to control the ndiff of stream by srs_rtmp_dump,
        # for example, some device can only accept some stream which
        # delivery packets in constant interval(not cbr).
        # @remark 0 to disable the minimal interval.
        # @remark >0 to make the srs to send message one by one.
        # @remark user can get the right packets interval in ms by srs_rtmp_dump.
        # default: 0
        send_min_interval       10.0;
        # whether reduce the sequence header,
        # for some client which cannot got duplicated sequence header,
        # while the sequence header is not changed yet.
        # default: off
        reduce_sequence_header  on;
    }
}

# vhost for time jitter
vhost jitter.srs.com {
    # @see play.srs.com
    # to use time_jitter full, the default config.
    play {
    }
    # to use mix_correct.
    play {
        time_jitter             off;
        mix_correct             on;
    }
    play {
        atc                     on;
        mix_correct             on;
    }
    # to use atc
    play {
        atc                     on;
    }
}

# vhost for atc.
vhost atc.srs.com {
    # @see play.srs.com
    play {
        atc             on;
        atc_auto        on;
    }
}

# the MR(merged-read) setting for publisher.
# the MW(merged-write) settings for player.
vhost mrw.srs.com {
    # @see scope.vhost.srs.com
    min_latency     off;

    # @see play.srs.com
    play {
        mw_latency      350;
        mw_msgs         8;
    }

    # @see publish.srs.com
    publish {
        mr          on;
        mr_latency  350;
    }
}

# the vhost for min delay, do not cache any stream.
vhost min.delay.com {
    # @see scope.vhost.srs.com
    min_latency     on;
    # @see scope.vhost.srs.com
    tcp_nodelay     on;

    # @see play.srs.com
    play {
        mw_latency      100;
        mw_msgs         4;
        gop_cache       off;
        queue_length    10;
    }

    # @see publish.srs.com
    publish {
        mr          off;
    }
}

# whether disable the sps parse, for the resolution of video.
vhost no.parse.sps.com {
    # @see publish.srs.com
    publish {
        parse_sps   on;
    }
}

# the vhost to control the stream delivery feature
vhost stream.control.com {
    # @see scope.vhost.srs.com
    min_latency     on;
    # @see scope.vhost.srs.com
    tcp_nodelay     on;

    # @see play.srs.com
    play {
        mw_latency      100;
        mw_msgs         4;
        queue_length    10;
        send_min_interval       10.0;
        reduce_sequence_header  on;
    }

    # @see publish.srs.com
    publish {
        mr          off;
        firstpkt_timeout    20000;
        normal_timeout      7000;
    }
}

# the publish specified configs
vhost publish.srs.com {
    # the config for FMLE/Flash publisher, which push RTMP to SRS.
    publish {
        # about MR, read https://github.com/ossrs/srs/issues/241
        # when enabled the mr, SRS will read as large as possible.
        # default: off
        mr          off;
        # the latency in ms for MR(merged-read),
        # the performance+ when latency+, and memory+,
        #       memory(buffer) = latency * kbps / 8
        # for example, latency=500ms, kbps=3000kbps, each publish connection will consume
        #       memory = 500 * 3000 / 8 = 187500B = 183KB
        # when there are 2500 publisher, the total memory of SRS at least:
        #       183KB * 2500 = 446MB
        # the recommended value is [300, 2000]
        # default: 350
        mr_latency  350;

        # the 1st packet timeout in ms for encoder.
        # default: 20000
        firstpkt_timeout    20000;
        # the normal packet timeout in ms for encoder.
        # default: 5000
        normal_timeout      7000;
        # whether parse the sps when publish stream.
        # we can got the resolution of video for stat api.
        # but we may failed to cause publish failed.
        # @remark If disabled, HLS might never update the sps/pps, it depends on this.
        # default: on
        parse_sps   on;
    }
}

# the vhost for anti-suck.
vhost refer.anti_suck.com {
    # refer hotlink-denial.
    refer {
        # whether enable the refer hotlink-denial.
        # default: off.
        enabled         on;
        # the common refer for play and publish.
        # if the page url of client not in the refer, access denied.
        # if not specified this field, allow all.
        # default: not specified.
        all           github.com github.io;
        # refer for publish clients specified.
        # the common refer is not overridden by this.
        # if not specified this field, allow all.
        # default: not specified.
        publish   github.com github.io;
        # refer for play clients specified.
        # the common refer is not overridden by this.
        # if not specified this field, allow all.
        # default: not specified.
        play      github.com github.io;
    }
}

# the security to allow or deny clients.
vhost security.srs.com {
    # security for host to allow or deny clients.
    # @see https://github.com/ossrs/srs/issues/211
    security {
        # whether enable the security for vhost.
        # default: off
        enabled         on;
        # the security list, each item format as:
        #       allow|deny    publish|play    all|<ip>
        # for example:
        #       allow           publish     all;
        #       deny            publish     all;
        #       allow           publish     127.0.0.1;
        #       deny            publish     127.0.0.1;
        #       allow           play        all;
        #       deny            play        all;
        #       allow           play        127.0.0.1;
        #       deny            play        127.0.0.1;
        # SRS apply the following simple strategies one by one:
        #       1. allow all if security disabled.
        #       2. default to deny all when security enabled.
        #       3. allow if matches allow strategy.
        #       4. deny if matches deny strategy.
        allow           play        all;
        allow           publish     all;
    }
}

# vhost for http static and flv vod stream for each vhost.
vhost http.static.srs.com {
    # http static vhost specified config
    http_static {
        # whether enabled the http static service for vhost.
        # default: off
        enabled     on;
        # the url to mount to,
        # typical mount to [vhost]/
        # the variables:
        #       [vhost] current vhost for http server.
        # @remark the [vhost] is optional, used to mount at specified vhost.
        # @remark the http of __defaultVhost__ will override the http_server section.
        # for example:
        #       mount to [vhost]/
        #           access by http://ossrs.net:8080/xxx.html
        #       mount to [vhost]/hls
        #           access by http://ossrs.net:8080/hls/xxx.html
        #       mount to /
        #           access by http://ossrs.net:8080/xxx.html
        #           or by http://192.168.1.173:8080/xxx.html
        #       mount to /hls
        #           access by http://ossrs.net:8080/hls/xxx.html
        #           or by http://192.168.1.173:8080/hls/xxx.html
        # @remark the port of http is specified by http_server section.
        # default: [vhost]/
        mount       [vhost]/hls;
        # main dir of vhost,
        # to delivery HTTP stream of this vhost.
        # default: ./objs/nginx/html
        dir         ./objs/nginx/html/hls;
    }
}

# vhost for http flv/aac/mp3 live stream for each vhost.
vhost http.remux.srs.com {
    # http flv/mp3/aac/ts stream vhost specified config
    http_remux {
        # whether enable the http live streaming service for vhost.
        # default: off
        enabled     on;
        # the fast cache for audio stream(mp3/aac),
        # to cache more audio and send to client in a time to make android(weixin) happy.
        # @remark the flv/ts stream ignore it
        # @remark 0 to disable fast cache for http audio stream.
        # default: 0
        fast_cache  30;
        # the stream mount for rtmp to remux to live streaming.
        # typical mount to [vhost]/[app]/[stream].flv
        # the variables:
        #       [vhost] current vhost for http live stream.
        #       [app] current app for http live stream.
        #       [stream] current stream for http live stream.
        # @remark the [vhost] is optional, used to mount at specified vhost.
        # the extension:
        #       .flv mount http live flv stream, use default gop cache.
        #       .ts mount http live ts stream, use default gop cache.
        #       .mp3 mount http live mp3 stream, ignore video and audio mp3 codec required.
        #       .aac mount http live aac stream, ignore video and audio aac codec required.
        # for example:
        #       mount to [vhost]/[app]/[stream].flv
        #           access by http://ossrs.net:8080/live/livestream.flv
        #       mount to /[app]/[stream].flv
        #           access by http://ossrs.net:8080/live/livestream.flv
        #           or by http://192.168.1.173:8080/live/livestream.flv
        #       mount to [vhost]/[app]/[stream].mp3
        #           access by http://ossrs.net:8080/live/livestream.mp3
        #       mount to [vhost]/[app]/[stream].aac
        #           access by http://ossrs.net:8080/live/livestream.aac
        #       mount to [vhost]/[app]/[stream].ts
        #           access by http://ossrs.net:8080/live/livestream.ts
        # @remark the port of http is specified by http_server section.
        # default: [vhost]/[app]/[stream].flv
        mount       [vhost]/[app]/[stream].flv;
    }
}

# the http hook callback vhost, srs will invoke the hooks for specified events.
vhost hooks.callback.srs.com {
    http_hooks {
        # whether the http hooks enable.
        # default off.
        enabled         on;
        # when client connect to vhost/app, call the hook,
        # the request in the POST data string is a object encode by json:
        #       {
        #           "action": "on_connect",
        #           "client_id": 1985,
        #           "ip": "192.168.1.10", "vhost": "video.test.com", "app": "live",
        #           "tcUrl": "rtmp://video.test.com/live?key=d2fa801d08e3f90ed1e1670e6e52651a",
        #           "pageUrl": "http://www.test.com/live.html", "server_id": "vid-werty"
        #       }
        # if valid, the hook must return HTTP code 200(Status OK) and response
        # an int value specifies the error code(0 corresponding to success):
        #       0
        # support multiple api hooks, format:
        #       on_connect http://xxx/api0 http://xxx/api1 http://xxx/apiN
        # @remark For SRS4, the HTTPS url is supported, for example:
        #       on_connect https://xxx/api0 https://xxx/api1 https://xxx/apiN
        on_connect      http://127.0.0.1:8085/api/v1/clients http://localhost:8085/api/v1/clients;
        # when client close/disconnect to vhost/app/stream, call the hook,
        # the request in the POST data string is a object encode by json:
        #       {
        #           "action": "on_close",
        #           "client_id": 1985,
        #           "ip": "192.168.1.10", "vhost": "video.test.com", "app": "live",
        #           "send_bytes": 10240, "recv_bytes": 10240, "server_id": "vid-werty"
        #       }
        # if valid, the hook must return HTTP code 200(Status OK) and response
        # an int value specifies the error code(0 corresponding to success):
        #       0
        # support multiple api hooks, format:
        #       on_close http://xxx/api0 http://xxx/api1 http://xxx/apiN
        # @remark For SRS4, the HTTPS url is supported, for example:
        #       on_close https://xxx/api0 https://xxx/api1 https://xxx/apiN
        on_close        http://127.0.0.1:8085/api/v1/clients http://localhost:8085/api/v1/clients;
        # when client(encoder) publish to vhost/app/stream, call the hook,
        # the request in the POST data string is a object encode by json:
        #       {
        #           "action": "on_publish",
        #           "client_id": 1985,
        #           "ip": "192.168.1.10", "vhost": "video.test.com", "app": "live",
        #           "stream": "livestream", "param":"?token=xxx&salt=yyy", "server_id": "vid-werty"
        #       }
        # if valid, the hook must return HTTP code 200(Status OK) and response
        # an int value specifies the error code(0 corresponding to success):
        #       0
        # support multiple api hooks, format:
        #       on_publish http://xxx/api0 http://xxx/api1 http://xxx/apiN
        # @remark For SRS4, the HTTPS url is supported, for example:
        #       on_publish https://xxx/api0 https://xxx/api1 https://xxx/apiN
        on_publish      http://127.0.0.1:8085/api/v1/streams http://localhost:8085/api/v1/streams;
        # when client(encoder) stop publish to vhost/app/stream, call the hook,
        # the request in the POST data string is a object encode by json:
        #       {
        #           "action": "on_unpublish",
        #           "client_id": 1985,
        #           "ip": "192.168.1.10", "vhost": "video.test.com", "app": "live",
        #           "stream": "livestream", "param":"?token=xxx&salt=yyy", "server_id": "vid-werty"
        #       }
        # if valid, the hook must return HTTP code 200(Status OK) and response
        # an int value specifies the error code(0 corresponding to success):
        #       0
        # support multiple api hooks, format:
        #       on_unpublish http://xxx/api0 http://xxx/api1 http://xxx/apiN
        # @remark For SRS4, the HTTPS url is supported, for example:
        #       on_unpublish https://xxx/api0 https://xxx/api1 https://xxx/apiN
        on_unpublish    http://127.0.0.1:8085/api/v1/streams http://localhost:8085/api/v1/streams;
        # when client start to play vhost/app/stream, call the hook,
        # the request in the POST data string is a object encode by json:
        #       {
        #           "action": "on_play",
        #           "client_id": 1985,
        #           "ip": "192.168.1.10", "vhost": "video.test.com", "app": "live",
        #           "stream": "livestream", "param":"?token=xxx&salt=yyy",
        #           "pageUrl": "http://www.test.com/live.html", "server_id": "vid-werty"
        #       }
        # if valid, the hook must return HTTP code 200(Status OK) and response
        # an int value specifies the error code(0 corresponding to success):
        #       0
        # support multiple api hooks, format:
        #       on_play http://xxx/api0 http://xxx/api1 http://xxx/apiN
        # @remark For SRS4, the HTTPS url is supported, for example:
        #       on_play https://xxx/api0 https://xxx/api1 https://xxx/apiN
        on_play         http://127.0.0.1:8085/api/v1/sessions http://localhost:8085/api/v1/sessions;
        # when client stop to play vhost/app/stream, call the hook,
        # the request in the POST data string is a object encode by json:
        #       {
        #           "action": "on_stop",
        #           "client_id": 1985,
        #           "ip": "192.168.1.10", "vhost": "video.test.com", "app": "live",
        #           "stream": "livestream", "param":"?token=xxx&salt=yyy", "server_id": "vid-werty"
        #       }
        # if valid, the hook must return HTTP code 200(Status OK) and response
        # an int value specifies the error code(0 corresponding to success):
        #       0
        # support multiple api hooks, format:
        #       on_stop http://xxx/api0 http://xxx/api1 http://xxx/apiN
        # @remark For SRS4, the HTTPS url is supported, for example:
        #       on_stop https://xxx/api0 https://xxx/api1 https://xxx/apiN
        on_stop         http://127.0.0.1:8085/api/v1/sessions http://localhost:8085/api/v1/sessions;
        # when srs reap a dvr file, call the hook,
        # the request in the POST data string is a object encode by json:
        #       {
        #           "action": "on_dvr",
        #           "client_id": 1985,
        #           "ip": "192.168.1.10", "vhost": "video.test.com", "app": "live",
        #           "stream": "livestream", "param":"?token=xxx&salt=yyy",
        #           "cwd": "/usr/local/srs",
        #           "file": "./objs/nginx/html/live/livestream.1420254068776.flv", "server_id": "vid-werty"
        #       }
        # if valid, the hook must return HTTP code 200(Status OK) and response
        # an int value specifies the error code(0 corresponding to success):
        #       0
        on_dvr          http://127.0.0.1:8085/api/v1/dvrs http://localhost:8085/api/v1/dvrs;
        # when srs reap a ts file of hls, call the hook,
        # the request in the POST data string is a object encode by json:
        #       {
        #           "action": "on_hls",
        #           "client_id": 1985,
        #           "ip": "192.168.1.10", "vhost": "video.test.com", "app": "live",
        #           "stream": "livestream", "param":"?token=xxx&salt=yyy",
        #           "duration": 9.36, // in seconds
        #           "cwd": "/usr/local/srs",
        #           "file": "./objs/nginx/html/live/livestream/2015-04-23/01/476584165.ts",
        #           "url": "live/livestream/2015-04-23/01/476584165.ts",
        #           "m3u8": "./objs/nginx/html/live/livestream/live.m3u8",
        #           "m3u8_url": "live/livestream/live.m3u8",
        #           "seq_no": 100, "server_id": "vid-werty"
        #       }
        # if valid, the hook must return HTTP code 200(Status OK) and response
        # an int value specifies the error code(0 corresponding to success):
        #       0
        on_hls          http://127.0.0.1:8085/api/v1/hls http://localhost:8085/api/v1/hls;
        # when srs reap a ts file of hls, call this hook,
        # used to push file to cdn network, by get the ts file from cdn network.
        # so we use HTTP GET and use the variable following:
        #       [server_id], replace with the server_id
        #       [app], replace with the app.
        #       [stream], replace with the stream.
        #       [param], replace with the param.
        #       [ts_url], replace with the ts url.
        # ignore any return data of server.
        # @remark random select a url to report, not report all.
        on_hls_notify   http://127.0.0.1:8085/api/v1/hls/[server_id]/[app]/[stream]/[ts_url][param];
    }
}

# the vhost for exec, fork process when publish stream.
vhost exec.srs.com {
    # the exec used to fork process when got some event.
    exec {
        # whether enable the exec.
        # default: off.
        enabled     off;
        # when publish stream, exec the process with variables:
        #       [vhost] the input stream vhost.
        #       [port] the input stream port.
        #       [app] the input stream app.
        #       [stream] the input stream name.
        #       [engine] the transcode engine name.
        # other variables for exec only:
        #       [url] the rtmp url which trigger the publish.
        #       [tcUrl] the client request tcUrl.
        #       [swfUrl] the client request swfUrl.
        #       [pageUrl] the client request pageUrl.
        # we also support datetime variables.
        #       [2006], replace this const to current year.
        #       [01], replace this const to current month.
        #       [02], replace this const to current date.
        #       [15], replace this const to current hour.
        #       [04], replace this const to current minute.
        #       [05], replace this const to current second.
        #       [999], replace this const to current millisecond.
        #       [timestamp],replace this const to current UNIX timestamp in ms.
        # @remark we use golang time format "2006-01-02 15:04:05.999" as "[2006]-[01]-[02]_[15].[04].[05]_[999]"
        # @remark empty to ignore this exec.
        publish     ./objs/ffmpeg/bin/ffmpeg -f flv -i [url] -c copy -y ./[stream].flv;
    }
}

# The vhost for MPEG-DASH.
vhost dash.srs.com {
    dash {
        # Whether DASH is enabled.
        # Transmux RTMP to DASH if on.
        # Default: off
        enabled             on;
        # The duration of segment in seconds.
        # Default: 30
        dash_fragment       30;
        # The period to update the MPD in seconds.
        # Default: 150
        dash_update_period  150;
        # The depth of timeshift buffer in seconds.
        # Default: 300
        dash_timeshift      300;
        # The base/home dir/path for dash.
        # All init and segment files will write under this dir.
        dash_path           ./objs/nginx/html;
        # The DASH MPD file path.
        # We supports some variables to generate the filename.
        #       [vhost], the vhost of stream.
        #       [app], the app of stream.
        #       [stream], the stream name of stream.
        # Default: [app]/[stream].mpd
        dash_mpd_file       [app]/[stream].mpd;
    }
}

# the vhost with hls specified.
vhost hls.srs.com {
    hls {
        # whether the hls is enabled.
        # if off, do not write hls(ts and m3u8) when publish.
        # default: off
        enabled         on;
        # the hls fragment in seconds, the duration of a piece of ts.
        # default: 10
        hls_fragment    10;
        # the hls m3u8 target duration ratio,
        #   EXT-X-TARGETDURATION = hls_td_ratio * hls_fragment // init
        #   EXT-X-TARGETDURATION = max(ts_duration, EXT-X-TARGETDURATION) // for each ts
        # @see https://github.com/ossrs/srs/issues/304#issuecomment-74000081
        # default: 1.5
        hls_td_ratio    1.5;
        # the audio overflow ratio.
        # for pure audio, the duration to reap the segment.
        # for example, the hls_fragment is 10s, hls_aof_ratio is 2.0,
        # the segment will reap to 20s for pure audio.
        # default: 2.0
        hls_aof_ratio   2.0;
        # the hls window in seconds, the number of ts in m3u8.
        # default: 60
        hls_window      60;
        # the error strategy. can be:
        #       ignore, disable the hls.
        #       disconnect, require encoder republish.
        #       continue, ignore failed try to continue output hls.
        # @see https://github.com/ossrs/srs/issues/264
        # default: continue
        hls_on_error    continue;
        # the hls output path.
        # the m3u8 file is configured by hls_path/hls_m3u8_file, the default is:
        #       ./objs/nginx/html/[app]/[stream].m3u8
        # the ts file is configured by hls_path/hls_ts_file, the default is:
        #       ./objs/nginx/html/[app]/[stream]-[seq].ts
        # @remark the hls_path is compatible with srs v1 config.
        # default: ./objs/nginx/html
        hls_path        ./objs/nginx/html;
        # the hls m3u8 file name.
        # we supports some variables to generate the filename.
        #       [vhost], the vhost of stream.
        #       [app], the app of stream.
        #       [stream], the stream name of stream.
        # default: [app]/[stream].m3u8
        hls_m3u8_file   [app]/[stream].m3u8;
        # the hls ts file name.
        # we supports some variables to generate the filename.
        #       [vhost], the vhost of stream.
        #       [app], the app of stream.
        #       [stream], the stream name of stream.
        #       [2006], replace this const to current year.
        #       [01], replace this const to current month.
        #       [02], replace this const to current date.
        #       [15], replace this const to current hour.
        #       [04], replace this const to current minute.
        #       [05], replace this const to current second.
        #       [999], replace this const to current millisecond.
        #       [timestamp],replace this const to current UNIX timestamp in ms.
        #       [seq], the sequence number of ts.
        #       [duration], replace this const to current ts duration.
        # @see https://github.com/ossrs/srs/wiki/v2_CN_DVR#custom-path
        # @see https://github.com/ossrs/srs/wiki/v2_CN_DeliveryHLS#hls-config
        # default: [app]/[stream]-[seq].ts
        hls_ts_file     [app]/[stream]-[seq].ts;
        # whether use floor for the hls_ts_file path generation.
        # if on, use floor(timestamp/hls_fragment) as the variable [timestamp],
        #       and use enhanced algorithm to calc deviation for segment.
        # @remark when floor on, recommend the hls_segment>=2*gop.
        # default: off
        hls_ts_floor    off;
        # the hls entry prefix, which is base url of ts url.
        # for example, the prefix is:
        #         http://your-server/
        # then, the ts path in m3u8 will be like:
        #         http://your-server/live/livestream-0.ts
        #         http://your-server/live/livestream-1.ts
        #         ...
        # optional, default to empty string.
        hls_entry_prefix http://your-server;
        # the default audio codec of hls.
        # when codec changed, write the PAT/PMT table, but maybe ok util next ts.
        # so user can set the default codec for mp3.
        # the available audio codec:
        #       aac, mp3, an
        # default: aac
        hls_acodec      aac;
        # the default video codec of hls.
        # when codec changed, write the PAT/PMT table, but maybe ok util next ts.
        # so user can set the default codec for pure audio(without video) to vn.
        # the available video codec:
        #       h264, vn
        # default: h264
        hls_vcodec      h264;
        # whether cleanup the old expired ts files.
        # default: on
        hls_cleanup     on;
        # If there is no incoming packets, dispose HLS in this timeout in seconds,
        # which removes all HLS files including m3u8 and ts files.
        # @remark 0 to disable dispose for publisher.
        # @remark apply for publisher timeout only, while "etc/init.d/srs stop" always dispose hls.
        # default: 0
        hls_dispose     0;
        # the max size to notify hls,
        # to read max bytes from ts of specified cdn network,
        # @remark only used when on_hls_notify is config.
        # default: 64
        hls_nb_notify   64;
        # whether wait keyframe to reap segment,
        # if off, reap segment when duration exceed the fragment,
        # if on, reap segment when duration exceed and got keyframe.
        # default: on
        hls_wait_keyframe       on;

        # whether using AES encryption.
        # default: off
        hls_keys        on; 
        # the number of clear ts which one key can encrypt.
        # default: 5
        hls_fragments_per_key 5;
        # the hls key file name.
        # we supports some variables to generate the filename.
        #       [vhost], the vhost of stream.
        #       [app], the app of stream.
        #       [stream], the stream name of stream.
        #       [seq], the sequence number of key corresponding to the ts.
        hls_key_file     [app]/[stream]-[seq].key;
        # the key output path.
        # the key file is configed by hls_path/hls_key_file, the default is:
        # ./objs/nginx/html/[app]/[stream]-[seq].key
        hls_key_file_path    ./objs/nginx/html;
        # the key root URL, use this can support https.
        # @remark It's optional.
        hls_key_url       https://localhost:8080;

        # Special control controls.
        ###########################################
        # Whether calculate the DTS of audio frame directly.
        # If on, guess the specific DTS by AAC samples, please read https://github.com/ossrs/srs/issues/547#issuecomment-294350544
        # If off, directly turn the FLV timestamp to DTS, which might cause corrupt audio stream.
        # @remark Recommend to set to off, unless your audio stream sample-rate and timestamp is not correct.
        # Default: on
        hls_dts_directly on;

        # on_hls, never config in here, should config in http_hooks.
        # for the hls http callback, @see http_hooks.on_hls of vhost hooks.callback.srs.com
        # @read https://github.com/ossrs/srs/wiki/v2_CN_DeliveryHLS#http-callback
        # @read https://github.com/ossrs/srs/wiki/v2_EN_DeliveryHLS#http-callback

        # on_hls_notify, never config in here, should config in http_hooks.
        # we support the variables to generate the notify url:
        #       [app], replace with the app.
        #       [stream], replace with the stream.
        #       [param], replace with the param.
        #       [ts_url], replace with the ts url.
        # for the hls http callback, @see http_hooks.on_hls_notify of vhost hooks.callback.srs.com
        # @read https://github.com/ossrs/srs/wiki/v2_CN_DeliveryHLS#on-hls-notify
        # @read https://github.com/ossrs/srs/wiki/v2_EN_DeliveryHLS#on-hls-notify
    }
}
# the vhost with hls disabled.
vhost no-hls.srs.com {
    hls {
        # whether the hls is enabled.
        # if off, do not write hls(ts and m3u8) when publish.
        # default: off
        enabled         off;
    }
}

# the vhost with adobe hds
vhost hds.srs.com {
    hds {
        # whether hds enabled
        # default: off
        enabled         on;
        # the hds fragment in seconds.
        # default: 10
        hds_fragment    10;
        # the hds window in seconds, erase the segment when exceed the window.
        # default: 60
        hds_window      60;
        # the path to store the hds files.
        # default: ./objs/nginx/html
        hds_path        ./objs/nginx/html;
    }
}

# vhost for dvr
vhost dvr.srs.com {
    # DVR RTMP stream to file,
    # start to record to file when encoder publish,
    # reap flv/mp4 according by specified dvr_plan.
    dvr {
        # whether enabled dvr features
        # default: off
        enabled         on;
        # the filter for dvr to apply to.
        #       all, dvr all streams of all apps.
        #       <app>/<stream>, apply to specified stream of app.
        # for example, to dvr the following two streams:
        #       live/stream1 live/stream2
        # @remark Reload is disabled, @see https://github.com/ossrs/srs/issues/2181
        # default: all
        dvr_apply       all;
        # the dvr plan. canbe:
        #       session reap flv/mp4 when session end(unpublish).
        #       segment reap flv/mp4 when flv duration exceed the specified dvr_duration.
        # @remark The plan append is removed in SRS3+, for it's no use.
        # default: session
        dvr_plan        session;
        # the dvr output path, *.flv or *.mp4.
        # we supports some variables to generate the filename.
        #       [vhost], the vhost of stream.
        #       [app], the app of stream.
        #       [stream], the stream name of stream.
        #       [2006], replace this const to current year.
        #       [01], replace this const to current month.
        #       [02], replace this const to current date.
        #       [15], replace this const to current hour.
        #       [04], replace this const to current minute.
        #       [05], replace this const to current second.
        #       [999], replace this const to current millisecond.
        #       [timestamp],replace this const to current UNIX timestamp in ms.
        # @remark we use golang time format "2006-01-02 15:04:05.999" as "[2006]-[01]-[02]_[15].[04].[05]_[999]"
        # for example, for url rtmp://ossrs.net/live/livestream and time 2015-01-03 10:57:30.776
        # 1. No variables, the rule of SRS1.0(auto add [stream].[timestamp].flv as filename):
        #       dvr_path ./objs/nginx/html;
        #       =>
        #       dvr_path ./objs/nginx/html/live/livestream.1420254068776.flv;
        # 2. Use stream and date as dir name, time as filename:
        #       dvr_path /data/[vhost]/[app]/[stream]/[2006]/[01]/[02]/[15].[04].[05].[999].flv;
        #       =>
        #       dvr_path /data/ossrs.net/live/livestream/2015/01/03/10.57.30.776.flv;
        # 3. Use stream and year/month as dir name, date and time as filename:
        #       dvr_path /data/[vhost]/[app]/[stream]/[2006]/[01]/[02]-[15].[04].[05].[999].flv;
        #       =>
        #       dvr_path /data/ossrs.net/live/livestream/2015/01/03-10.57.30.776.flv;
        # 4. Use vhost/app and year/month as dir name, stream/date/time as filename:
        #       dvr_path /data/[vhost]/[app]/[2006]/[01]/[stream]-[02]-[15].[04].[05].[999].flv;
        #       =>
        #       dvr_path /data/ossrs.net/live/2015/01/livestream-03-10.57.30.776.flv;
        # 5. DVR to mp4:
        #       dvr_path ./objs/nginx/html/[app]/[stream].[timestamp].mp4;
        #       =>
        #       dvr_path ./objs/nginx/html/live/livestream.1420254068776.mp4;
        # @see https://github.com/ossrs/srs/wiki/v3_CN_DVR#custom-path
        # @see https://github.com/ossrs/srs/wiki/v3_EN_DVR#custom-path
        #       segment,session apply it.
        # default: ./objs/nginx/html/[app]/[stream].[timestamp].flv
        dvr_path        ./objs/nginx/html/[app]/[stream].[timestamp].flv;
        # the duration for dvr file, reap if exceed, in seconds.
        #       segment apply it.
        #       session,append ignore.
        # default: 30
        dvr_duration    30;
        # whether wait keyframe to reap segment,
        # if off, reap segment when duration exceed the dvr_duration,
        # if on, reap segment when duration exceed and got keyframe.
        #       segment apply it.
        #       session,append ignore.
        # default: on
        dvr_wait_keyframe       on;
        # about the stream monotonically increasing:
        #   1. video timestamp is monotonically increasing,
        #   2. audio timestamp is monotonically increasing,
        #   3. video and audio timestamp is interleaved monotonically increasing.
        # it's specified by RTMP specification, @see 3. Byte Order, Alignment, and Time Format
        # however, some encoder cannot provides this feature, please set this to off to ignore time jitter.
        # the time jitter algorithm:
        #   1. full, to ensure stream start at zero, and ensure stream monotonically increasing.
        #   2. zero, only ensure stream start at zero, ignore timestamp jitter.
        #   3. off, disable the time jitter algorithm, like atc.
        # apply for all dvr plan.
        # default: full
        time_jitter             full;

        # on_dvr, never config in here, should config in http_hooks.
        # for the dvr http callback, @see http_hooks.on_dvr of vhost hooks.callback.srs.com
        # @read https://github.com/ossrs/srs/wiki/v2_CN_DVR#http-callback
        # @read https://github.com/ossrs/srs/wiki/v2_EN_DVR#http-callback
    }
}

# vhost for ingest
vhost ingest.srs.com {
    # ingest file/stream/device then push to SRS over RTMP.
    # the name/id used to identify the ingest, must be unique in global.
    # ingest id is used in reload or http api management.
    # @remark vhost can contains multiple ingest
    ingest livestream {
        # whether enabled ingest features
        # default: off
        enabled      on;
        # input file/stream/device
        # @remark only support one input.
        input {
            # the type of input.
            # can be file/stream/device, that is,
            #   file: ingest file specified by url.
            #   stream: ingest stream specified by url.
            #   device: not support yet.
            # default: file
            type    file;
            # the url of file/stream.
            url     ./doc/source.200kbps.768x320.flv;
        }
        # the ffmpeg
        ffmpeg      ./objs/ffmpeg/bin/ffmpeg;
        # the transcode engine, @see all.transcode.srs.com
        # @remark, the output is specified following.
        engine {
            # @see enabled of transcode engine.
            # if disabled or vcodec/acodec not specified, use copy.
            # default: off.
            enabled          off;
            # output stream. variables:
            #       [vhost] current vhost which start the ingest.
            #       [port] system RTMP stream port.
            # we also support datetime variables.
            #       [2006], replace this const to current year.
            #       [01], replace this const to current month.
            #       [02], replace this const to current date.
            #       [15], replace this const to current hour.
            #       [04], replace this const to current minute.
            #       [05], replace this const to current second.
            #       [999], replace this const to current millisecond.
            #       [timestamp],replace this const to current UNIX timestamp in ms.
            # @remark we use golang time format "2006-01-02 15:04:05.999" as "[2006]-[01]-[02]_[15].[04].[05]_[999]"
            output          rtmp://127.0.0.1:[port]/live?vhost=[vhost]/livestream;
        }
    }
}

# the vhost for ingest with transcode engine.
vhost transcode.ingest.srs.com {
    ingest livestream {
        enabled      on;
        input {
            type    file;
            url     ./doc/source.200kbps.768x320.flv;
        }
        ffmpeg      ./objs/ffmpeg/bin/ffmpeg;
        engine {
            enabled         off;
            perfile {
                re;
                rtsp_transport tcp;
            }
            iformat         flv;
            vfilter {
                i               ./doc/ffmpeg-logo.png;
                filter_complex  'overlay=10:10';
            }
            vcodec          libx264;
            vbitrate        1500;
            vfps            25;
            vwidth          768;
            vheight         320;
            vthreads        12;
            vprofile        main;
            vpreset         medium;
            vparams {
                t               100;
                coder           1;
                b_strategy      2;
                bf              3;
                refs            10;
            }
            acodec          libfdk_aac;
            abitrate        70;
            asample_rate    44100;
            achannels       2;
            aparams {
                profile:a   aac_low;
            }
            oformat         flv;
            output          rtmp://127.0.0.1:[port]/[app]?vhost=[vhost]/[stream];
        }
    }
}

# the main comments for transcode
vhost example.transcode.srs.com {
    # the streaming transcode configs.
    # @remark vhost can contains multiple transcode
    transcode {
        # whether the transcode enabled.
        # if off, donot transcode.
        # default: off.
        enabled     on;
        # the ffmpeg
        ffmpeg      ./objs/ffmpeg/bin/ffmpeg;
        # the transcode engine for matched stream.
        # all matched stream will transcoded to the following stream.
        # the transcode set name(ie. hd) is optional and not used.
        # we will build the parameters to fork ffmpeg:
        #       ffmpeg <perfile>
        #               -i <iformat> 
        #               <vfilter> 
        #               -vcodec <vcodec> -b:v <vbitrate> -r <vfps> -s <vwidth>x<vheight> -profile:v <vprofile> -preset <vpreset>
        #               <vparams>
        #               -acodec <acodec> -b:a <abitrate> -ar <asample_rate> -ac <achannels>
        #               <aparams>
        #               -f <oformat>
        #               -y <output>
        engine example {
            # whether the engine is enabled
            # default: off.
            enabled         on;
            # pre-file options, before "-i"
            perfile {
                re;
                rtsp_transport tcp;
            }
            # input format "-i", can be:
            #       off, do not specifies the format, ffmpeg will guess it.
            #       flv, for flv or RTMP stream.
            #       other format, for example, mp4/aac whatever.
            # default: flv
            iformat         flv;
            # ffmpeg filters, between "-i" and "-vcodec"
            # follows the main input.
            vfilter {
                # the logo input file.
                i               ./doc/ffmpeg-logo.png;
                # the ffmpeg complex filter.
                # for filters, @see: http://ffmpeg.org/ffmpeg-filters.html
                filter_complex  'overlay=10:10';
            }
            # video encoder name, "ffmpeg -vcodec"
            # can be:
            #       libx264: use h.264(libx264) video encoder.
            #       png: use png to snapshot thumbnail.
            #       copy: donot encoder the video stream, copy it.
            #       vn: disable video output.
            vcodec          libx264;
            # video bitrate, in kbps, "ffmepg -b:v"
            # @remark 0 to use source video bitrate.
            # default: 0
            vbitrate        1500;
            # video framerate, "ffmepg -r"
            # @remark 0 to use source video fps.
            # default: 0
            vfps            25;
            # video width, must be even numbers, "ffmepg -s"
            # @remark 0 to use source video width.
            # default: 0
            vwidth          768;
            # video height, must be even numbers, "ffmepg -s"
            # @remark 0 to use source video height.
            # default: 0
            vheight         320;
            # the max threads for ffmpeg to used, "ffmepg -thread"
            # default: 1
            vthreads        12;
            # x264 profile, "ffmepg -profile:v"
            # @see x264 -help, can be:
            # high,main,baseline
            vprofile        main;
            # x264 preset, "ffmpeg -preset"
            # @see x264 -help, can be:
            #       ultrafast,superfast,veryfast,faster,fast
            #       medium,slow,slower,veryslow,placebo
            vpreset         medium;
            # other x264 or ffmpeg video params, between "-preset" and "-acodec"
            vparams {
                # ffmpeg options, @see: http://ffmpeg.org/ffmpeg.html
                t               100;
                # 264 params, @see: http://ffmpeg.org/ffmpeg-codecs.html#libx264
                coder           1;
                b_strategy      2;
                bf              3;
                refs            10;
            }
            # audio encoder name, "ffmpeg -acodec"
            # can be:
            #       libfdk_aac: use aac(libfdk_aac) audio encoder.
            #       copy: donot encoder the audio stream, copy it.
            #       an: disable audio output.
            acodec          libfdk_aac;
            # audio bitrate, in kbps, "ffmpeg -b:a"
            # [16, 72] for libfdk_aac.
            # @remark 0 to use source audio bitrate.
            # default: 0
            abitrate        70;
            # audio sample rate, "ffmpeg -ar"
            # for flv/rtmp, it must be:
            #       44100,22050,11025,5512
            # @remark 0 to use source audio sample rate.
            # default: 0
            asample_rate    44100;
            # audio channel, "ffmpeg -ac"
            # 1 for mono, 2 for stereo.
            # @remark 0 to use source audio channels.
            # default: 0
            achannels       2;
            # other ffmpeg audio params, between "-ac" and "-f"/"-y"
            aparams {
                # audio params, @see: http://ffmpeg.org/ffmpeg-codecs.html#Audio-Encoders
                # @remark SRS supported aac profile for HLS is: aac_low, aac_he, aac_he_v2
                profile:a   aac_low;
                bsf:a       aac_adtstoasc;
            }
            # output format, "ffmpeg -f" can be:
            #       off, do not specifies the format, ffmpeg will guess it.
            #       flv, for flv or RTMP stream.
            #       image2, for vcodec png to snapshot thumbnail.
            #       other format, for example, mp4/aac whatever.
            # default: flv
            oformat         flv;
            # output stream, "ffmpeg -y", variables:
            #       [vhost] the input stream vhost.
            #       [port] the input stream port.
            #       [app] the input stream app.
            #       [stream] the input stream name.
            #       [engine] the transcode engine name.
            # we also support datetime variables.
            #       [2006], replace this const to current year.
            #       [01], replace this const to current month.
            #       [02], replace this const to current date.
            #       [15], replace this const to current hour.
            #       [04], replace this const to current minute.
            #       [05], replace this const to current second.
            #       [999], replace this const to current millisecond.
            #       [timestamp],replace this const to current UNIX timestamp in ms.
            # @remark we use golang time format "2006-01-02 15:04:05.999" as "[2006]-[01]-[02]_[15].[04].[05]_[999]"
            output          rtmp://127.0.0.1:[port]/[app]?vhost=[vhost]/[stream]_[engine];
        }
    }
}
# the mirror filter of ffmpeg, @see: http://ffmpeg.org/ffmpeg-filters.html#Filtering-Introduction
vhost mirror.transcode.srs.com {
    transcode {
        enabled     on;
        ffmpeg      ./objs/ffmpeg/bin/ffmpeg;
        engine mirror {
            enabled         on;
            vfilter {
                vf                  'split [main][tmp]; [tmp] crop=iw:ih/2:0:0, vflip [flip]; [main][flip] overlay=0:H/2';
            }
            vcodec          libx264;
            vbitrate        300;
            vfps            20;
            vwidth          768;
            vheight         320;
            vthreads        2;
            vprofile        baseline;
            vpreset         superfast;
            vparams {
            }
            acodec          libfdk_aac;
            abitrate        45;
            asample_rate    44100;
            achannels       2;
            aparams {
            }
            output          rtmp://127.0.0.1:[port]/[app]?vhost=[vhost]/[stream]_[engine];
        }
    }
}
# the drawtext filter of ffmpeg, @see: http://ffmpeg.org/ffmpeg-filters.html#drawtext-1
# remark: we remove the libfreetype which always cause build failed, you must add it manual if needed.
#######################################################################################################
# the crop filter of ffmpeg, @see: http://ffmpeg.org/ffmpeg-filters.html#crop
vhost crop.transcode.srs.com {
    transcode {
        enabled     on;
        ffmpeg      ./objs/ffmpeg/bin/ffmpeg;
        engine crop {
            enabled         on;
            vfilter {
                vf                  'crop=in_w-20:in_h-160:10:80';
            }
            vcodec          libx264;
            vbitrate        300;
            vfps            20;
            vwidth          768;
            vheight         320;
            vthreads        2;
            vprofile        baseline;
            vpreset         superfast;
            vparams {
            }
            acodec          libfdk_aac;
            abitrate        45;
            asample_rate    44100;
            achannels       2;
            aparams {
            }
            output          rtmp://127.0.0.1:[port]/[app]?vhost=[vhost]/[stream]_[engine];
        }
    }
}
# the logo filter of ffmpeg, @see: http://ffmpeg.org/ffmpeg-filters.html#overlay
vhost logo.transcode.srs.com {
    transcode {
        enabled     on;
        ffmpeg      ./objs/ffmpeg/bin/ffmpeg;
        engine logo {
            enabled         on;
            vfilter {
                i               ./doc/ffmpeg-logo.png;
                filter_complex      'overlay=10:10';
            }
            vcodec          libx264;
            vbitrate        300;
            vfps            20;
            vwidth          768;
            vheight         320;
            vthreads        2;
            vprofile        baseline;
            vpreset         superfast;
            vparams {
            }
            acodec          libfdk_aac;
            abitrate        45;
            asample_rate    44100;
            achannels       2;
            aparams {
            }
            output          rtmp://127.0.0.1:[port]/[app]?vhost=[vhost]/[stream]_[engine];
        }
    }
}
# audio transcode only.
# for example, FMLE publish audio codec in mp3, and do not support HLS output,
# we can transcode the audio to aac and copy video to the new stream with HLS.
vhost audio.transcode.srs.com {
    transcode {
        enabled     on;
        ffmpeg      ./objs/ffmpeg/bin/ffmpeg;
        engine acodec {
            enabled         on;
            vcodec          copy;
            acodec          libfdk_aac;
            abitrate        45;
            asample_rate    44100;
            achannels       2;
            aparams {
            }
            output          rtmp://127.0.0.1:[port]/[app]?vhost=[vhost]/[stream]_[engine];
        }
    }
}
# disable video, transcode/copy audio.
# for example, publish pure audio stream.
vhost vn.transcode.srs.com {
    transcode {
        enabled     on;
        ffmpeg      ./objs/ffmpeg/bin/ffmpeg;
        engine vn {
            enabled         on;
            vcodec          vn;
            acodec          libfdk_aac;
            abitrate        45;
            asample_rate    44100;
            achannels       2;
            aparams {
            }
            output          rtmp://127.0.0.1:[port]/[app]?vhost=[vhost]/[stream]_[engine];
        }
    }
}
# ffmpeg-copy(forward implements by ffmpeg).
# copy the video and audio to a new stream.
vhost copy.transcode.srs.com {
    transcode {
        enabled     on;
        ffmpeg      ./objs/ffmpeg/bin/ffmpeg;
        engine copy {
            enabled         on;
            vcodec          copy;
            acodec          copy;
            output          rtmp://127.0.0.1:[port]/[app]?vhost=[vhost]/[stream]_[engine];
        }
    }
}
# transcode all app and stream of vhost
# the comments, read example.transcode.srs.com
vhost all.transcode.srs.com {
    transcode {
        enabled     on;
        ffmpeg      ./objs/ffmpeg/bin/ffmpeg;
        engine ffsuper {
            enabled         on;
            iformat         flv;
            vfilter {
                i               ./doc/ffmpeg-logo.png;
                filter_complex  'overlay=10:10';
            }
            vcodec          libx264;
            vbitrate        1500;
            vfps            25;
            vwidth          768;
            vheight         320;
            vthreads        12;
            vprofile        main;
            vpreset         medium;
            vparams {
                t               100;
                coder           1;
                b_strategy      2;
                bf              3;
                refs            10;
            }
            acodec          libfdk_aac;
            abitrate        70;
            asample_rate    44100;
            achannels       2;
            aparams {
                profile:a   aac_low;
            }
            oformat         flv;
            output          rtmp://127.0.0.1:[port]/[app]?vhost=[vhost]/[stream]_[engine];
        }
        engine ffhd {
            enabled         on;
            vcodec          libx264;
            vbitrate        1200;
            vfps            25;
            vwidth          1382;
            vheight         576;
            vthreads        6;
            vprofile        main;
            vpreset         medium;
            vparams {
            }
            acodec          libfdk_aac;
            abitrate        70;
            asample_rate    44100;
            achannels       2;
            aparams {
            }
            output          rtmp://127.0.0.1:[port]/[app]?vhost=[vhost]/[stream]_[engine];
        }
        engine ffsd {
            enabled         on;
            vcodec          libx264;
            vbitrate        800;
            vfps            25;
            vwidth          1152;
            vheight         480;
            vthreads        4;
            vprofile        main;
            vpreset         fast;
            vparams {
            }
            acodec          libfdk_aac;
            abitrate        60;
            asample_rate    44100;
            achannels       2;
            aparams {
            }
            output          rtmp://127.0.0.1:[port]/[app]?vhost=[vhost]/[stream]_[engine];
        }
        engine fffast {
            enabled     on;
            vcodec          libx264;
            vbitrate        300;
            vfps            20;
            vwidth          768;
            vheight         320;
            vthreads        2;
            vprofile        baseline;
            vpreset         superfast;
            vparams {
            }
            acodec          libfdk_aac;
            abitrate        45;
            asample_rate    44100;
            achannels       2;
            aparams {
            }
            output          rtmp://127.0.0.1:[port]/[app]?vhost=[vhost]/[stream]_[engine];
        }
        engine vcopy {
            enabled         on;
            vcodec          copy;
            acodec          libfdk_aac;
            abitrate        45;
            asample_rate    44100;
            achannels       2;
            aparams {
            }
            output          rtmp://127.0.0.1:[port]/[app]?vhost=[vhost]/[stream]_[engine];
        }
        engine acopy {
            enabled     on;
            vcodec          libx264;
            vbitrate        300;
            vfps            20;
            vwidth          768;
            vheight         320;
            vthreads        2;
            vprofile        baseline;
            vpreset         superfast;
            vparams {
            }
            acodec          copy;
            output          rtmp://127.0.0.1:[port]/[app]?vhost=[vhost]/[stream]_[engine];
        }
        engine copy {
            enabled         on;
            vcodec          copy;
            acodec          copy;
            output          rtmp://127.0.0.1:[port]/[app]?vhost=[vhost]/[stream]_[engine];
        }
    }
}
# transcode all app and stream of app
vhost app.transcode.srs.com {
    # the streaming transcode configs.
    # if app specified, transcode all streams of app.
    transcode live {
        enabled     on;
        ffmpeg      ./objs/ffmpeg/bin/ffmpeg;
        engine {
            enabled     off;
        }
    }
}
# transcode specified stream.
vhost stream.transcode.srs.com {
    # the streaming transcode configs.
    # if stream specified, transcode the matched stream.
    transcode live/livestream {
        enabled     on;
        ffmpeg      ./objs/ffmpeg/bin/ffmpeg;
        engine {
            enabled     off;
        }
    }
}

#############################################################################################
# The origin cluster section
#############################################################################################
http_api {
    enabled         on;
    listen          9090;
}
vhost a.origin.cluster.srs.com {
    cluster {
        mode                local;
        origin_cluster      on;
        coworkers           127.0.0.1:9091;
    }
}

http_api {
    enabled         on;
    listen          9091;
}
vhost b.origin.cluster.srs.com {
    cluster {
        mode                local;
        origin_cluster      on;
        coworkers           127.0.0.1:9090;
    }
}

#############################################################################################
# To prevent user to use full.conf
#############################################################################################
# To identify the full.conf
# @remark Should never use it directly, it's only a collections of all config items.
# Default: off
is_full on;
